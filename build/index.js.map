{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import * as Promise from 'bluebird'\nimport * as parser from 'docker-file-parser'\nimport * as fs from 'fs'\nimport * as jsesc from 'jsesc'\nimport * as _ from 'lodash'\nimport * as path from 'path'\nimport * as tar from 'tar-stream'\n\nconst streamToPromise = require('stream-to-promise')\n\n/**\n * TransposeOptions:\n *\tOptions to be passed to the transpose module\n */\nexport interface TransposeOptions {\n\t/**\n\t * hostQemuPath: the path of the qemu binary on the host\n\t */\n\thostQemuPath: string\n\n\t/**\n\t * containerQemuPath: Where to add the qemu binary on-container\n\t */\n\tcontainerQemuPath: string\n}\n\ntype CommandTransposer = (options: TransposeOptions, command: parser.Command) => parser.Command\n\nconst generateQemuCopy = (options: TransposeOptions): parser.Command => {\n\treturn {\n\t\tname: 'COPY',\n\t\targs: [options.hostQemuPath, options.containerQemuPath]\n\t}\n}\n\nconst processArgString = (argString: string) => {\n\treturn jsesc(argString, { quotes: 'double' })\n}\n\nconst transposeArrayRun = (options: TransposeOptions, command: parser.Command): parser.Command => {\n\tconst args = (command.args as string[]).map(processArgString).join(' ')\n\treturn {\n\t\tname: 'RUN',\n\t\targs: [options.containerQemuPath, '-execve', '/bin/sh', '-c'].concat(args)\n\t}\n}\n\nconst transposeStringRun = (options: TransposeOptions, command: parser.Command): parser.Command => {\n \tconst processed = processArgString(command.args as string)\n\treturn {\n\t\tname: 'RUN',\n\t\targs:\t[options.containerQemuPath, '-execve', '/bin/sh', '-c'].concat([processed])\n\t}\n}\n\nconst transposeRun = (options: TransposeOptions, command: parser.Command): parser.Command => {\n\tif (_.isArray(command.args)) {\n\t\treturn transposeArrayRun(options, command)\n\t}\n\treturn transposeStringRun(options, command)\n}\n\nconst identity = (options: TransposeOptions, command: parser.Command): parser.Command => {\n\treturn command\n}\n\nconst commandToTranspose = (command: parser.Command): CommandTransposer => {\n\tif (command.name === 'RUN') {\n\t\treturn transposeRun\n\t}\n\treturn identity\n}\n\nconst argsToString = (args: string | { [key: string]: string } | string[]): string => {\n\tif (_.isArray(args)) {\n\t\treturn '[\"' + args.join('\",\"') + '\"]'\n\t} else {\n\t\treturn args as string\n\t}\n}\n\nconst commandsToDockerfile = (commands: parser.Command[]): string => {\n\tlet dockerfile = ''\n\n\tcommands.map((command) => {\n\t\tdockerfile += `${command.name} ${argsToString(command.args)}\\n`\n\t})\n\treturn dockerfile\n}\n\n/**\n * transpose:\n *\tGiven a string representing a dockerfile, transpose it to use qemu\n *\trather than native, to enable emulated builds\n *\n * @param dockerfile\n *\tA string representing the dockerfile\n * @param options\n *\tOPtions to use when doing the transposing\n */\nexport function transpose(dockerfile: string, options: TransposeOptions): string {\n\n\t// parse the Dokerfile\n\tconst commands = parser.parse(dockerfile, { includeComments: false })\n\n\tconst firstRunIdx = _.findIndex(commands, (command) => command.name === 'RUN')\n\n\tlet outCommands = commands.slice(0, firstRunIdx)\n\n\toutCommands.push(generateQemuCopy(options))\n\n\toutCommands = outCommands.concat(\n\t\tcommands.slice(firstRunIdx).map(\n\t\t\t(command) => commandToTranspose(command)(options, command)\n\t\t)\n\t)\n\n\treturn commandsToDockerfile(outCommands)\n}\n\n// FIXME: This is taken from resin-io-modules/resin-bundle-resolve\n// export this code to a shared module and import it in this project\n// and resin-bundle-resolve\nexport function normalizeTarEntry(name: string): string {\n  const normalized = path.normalize(name)\n  if (path.isAbsolute(normalized)) {\n    return normalized.substr(normalized.indexOf('/') + 1)\n  }\n  return normalized\n}\n\nconst getTarEntryHandler = (pack: tar.Pack, dockerfileName: string, opts: TransposeOptions) => {\n\n\treturn (header: tar.TarHeader, stream: NodeJS.ReadableStream, next: (err?: Error) => void) => {\n\t\tstreamToPromise(stream)\n\t\t.then((buffer: Buffer) => {\n\t\t\tif (normalizeTarEntry(header.name) === dockerfileName) {\n\t\t\t\tconst newDockerfile = transpose(buffer.toString(), opts)\n\t\t\t\tpack.entry({ name: 'Dockerfile' }, newDockerfile)\n\t\t\t} else {\n\t\t\t\tpack.entry(header, buffer)\n\t\t\t}\n\t\t\tnext()\n\t\t})\n\t}\n}\n\nexport function transposeTarStream(tarStream: NodeJS.ReadableStream,\n                                   options: TransposeOptions,\n                                   dockerfileName: string = 'Dockerfile') {\n\tconst extract = tar.extract()\n\tconst pack = tar.pack()\n\n\treturn new Promise<NodeJS.ReadableStream>((resolve, reject) => {\n\n\t\textract.on('entry', getTarEntryHandler(pack, dockerfileName, options))\n\n\t\textract.on('finish', () => {\n\t\t\tpack.finalize()\n\t\t\tresolve(pack)\n\t\t})\n\n\t\ttarStream.pipe(extract)\n\t})\n\n}\n"],"sourceRoot":"src"}